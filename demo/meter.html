<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Meter View</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #warnmsg {
      background-color: #ff6666;
      padding: 5px;
    }

    table {
      border-collapse: collapse;
      width: 60%;
      margin-top: 20px;
    }

    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f4f4f4;
    }
  </style>
</head>
<body>

<p>
  Demonstration of how you can use gonrg to create a web
  application. Select a meter from the selector below.
  The table with the meter readings will be displayed
  and will be updated live.
</p>


<label for="server-select">Server:</label>
<select id="server-select">
  <!-- ---------------
  // Edit this to point to your gonrg server(s).
  // Be sure to set alloworigin in gonrg to wherever this
  // runs. -->
  <option value="http://localhost:8080">My Local Meter Server</option>
  <option value="http://otherserver:8123">My Local Meter Server 2</option>
</select>

<label for="meter-select">Meter:</label>
<select id="meter-select">
  <!-- Filled by JavaScript -->
</select>

<p id="warnmsg" style="display: none"></p>

<h2>Meter Values</h2>

<table id="data-table">
  <thead>
    <tr>
      <th>Exact Key</th>
      <th>Simple Key</th>
      <th>Name</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <!-- Filled by JavaScript -->
  </tbody>
</table>

<script>

  const tableBody = document.querySelector("#data-table tbody");
  const serverSelect = document.getElementById("server-select");
  const meterSelect = document.getElementById("meter-select");
  const warnmsg = document.getElementById("warnmsg");
  const reconnectTime = 10000
  
  let dataMap = new Map(); // Keeps current state by ID
  let socket = null;
  let currentMeter = null;
  let apibase = serverSelect.value

  // Render the entire table from dataMap
  function renderTable() {
    tableBody.innerHTML = "";
    for (const item of dataMap.values()) {
      const row = document.createElement("tr");
      const value = prettyValue(item)
      row.innerHTML = `
        <td>${item.exactKey}</td>
        <td>${item.simplifiedKey}</td>
        <td>${item.name}</td>
        <td>${value}</td>
      `;
      tableBody.appendChild(row);
    }
  }

  function msg(message) {
    if (message === "") {
      warnmsg.textContent = ""
      warnmsg.style.display = "none"
      return
    }
    warnmsg.textContent = message
    warnmsg.style.display = "block"
  }

  // Initial HTTP GET request
  async function loadInitialData(meter) {
    try {
      const response = await fetch(subUrl(apibase, `meter/${meter}`));
      const jsonData = await response.json();

      dataMap.clear();

      jsonData.list.forEach(item => {
        dataMap.set(item.exactKey, item);
      });

      renderTable();
      msg("")
    } catch (error) {
      console.error("Failed to load initial data:", error);
      msg("failed to load initial data, is the server running?")
    }
  }

  function setupWebSocket(meter) {
    if (socket) {
      socket.close();
    }
    setupWebSocketRaw(meter)
  }

  // WebSocket setup
  function setupWebSocketRaw(meter) {

    socket = new WebSocket(subUrl(getWsUrl(apibase), `ws/meter/${meter}`));

    socket.onopen = () => {
      msg("")
      console.log("WebSocket connected");
    };

    socket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      message.list.forEach(item => {
        dataMap.set(item.exactKey, item);
      });
      renderTable();
    };

    socket.onerror = (error) => {
      msg("WebSocket error, data may not be accurate")
      console.error("WebSocket error:", error);
    };

    socket.onclose = () => {
      if (meter != currentMeter) {
        console.log("WebSocket closed because of meter change.");
        return
      }
      console.log("WebSocket closed, will reconnect after some time...");
      setTimeout(function() {
        if (meter == currentMeter) setupWebSocketRaw(meter)
      }, reconnectTime);
    };
  }

  function subUrl(httpUrl, subpath) {
    const url = new URL(httpUrl);
    url.pathname = `${url.pathname}${subpath}`;
    return url.toString();
  }

  function getWsUrl(httpUrl) {
    const url = new URL(httpUrl);
    if (url.protocol === "http:") {
      url.protocol = "ws:";
    } else if (url.protocol === "https:") {
      url.protocol = "wss:";
    } else {
      throw new Error("URL must start with http:// or https://");
    }
    return url.toString();
  }

  async function changeMeter(meter) {
    if (meter === currentMeter) return;

    currentMeter = meter;
    await loadInitialData(meter);
    setupWebSocket(meter);
  }

  async function loadMeters() {
    try {
      const response = await fetch(subUrl(apibase, "meters"));
      const sources = await response.json();

      meterSelect.innerHTML = "";
      sources.forEach(source => {
        const option = document.createElement("option");
        option.value = source;
        option.textContent = source;
        meterSelect.appendChild(option);
      });

      if (sources.length > 0) {
        changeMeter(sources[0]);
      }

    } catch (error) {
      msg("failed to load meters, is the server running?")
      console.error("error loading meters:", error);
    }
  }

  function prettyValue(item) {
    if (item.valueText) {
      return item.valueText
    }

    let valFloat = item.valueNum * 10 ** item.valueScale
    if (item.valueScale < 0) {
      valFloat = valFloat.toFixed(-item.valueScale)
    }

    if (item.unit) {
      return `${valFloat} ${item.unit}`
    }

    return `${valFloat}`
  }

  function changeServer(server) {
    if (apibase === server) return;
    apibase = server;
    loadMeters();
  }

  serverSelect.addEventListener("change", (e) => {
    changeServer(e.target.value);
  });

  meterSelect.addEventListener("change", (e) => {
    changeMeter(e.target.value);
  });

  window.addEventListener("load", () => {
    loadMeters();
  });
</script>

</body>
</html>
